{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nFrontLeft = Motor(Ports.PORT9, GearSetting.RATIO_18_1, False)\nFrontRight = Motor(Ports.PORT10, GearSetting.RATIO_18_1, True)\ncontroller_1 = Controller(PRIMARY)\nBackLeft = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nBackRight = Motor(Ports.PORT2, GearSetting.RATIO_18_1, True)\nCatapult1 = Motor(Ports.PORT8, GearSetting.RATIO_18_1, True)\nCatapult2 = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\nLeftExpand = Motor(Ports.PORT11, GearSetting.RATIO_18_1, False)\nRightExpand = Motor(Ports.PORT20, GearSetting.RATIO_18_1, True)\nGPS_Sense = Gps(Ports.PORT4, 0.00, 0.00, MM, 180)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n#################### Setup ####################\nglobal SpeedMult, MatchLoad, Expand, Preset, Timeout, debug\n# Sets Debug Mode To False\ndebug = False\n# Sets The Multiplier For The Throttle\nSpeedMult = 1\n# Sets MatchLoading To False\nMatchLoad = False\n# Sets Preset To False\nPreset = False\nTimeout = False\nWheelC = 259.34 # Wheel Circumference \nratio = .6 # Wheel Gear Ratio\n# Sets The Motors To Hold Their Position Upon Stopping\nFrontRight.set_stopping(BRAKE)\nFrontLeft.set_stopping(BRAKE)\nBackRight.set_stopping(BRAKE)\nBackLeft.set_stopping(BRAKE)\nLeftExpand.set_stopping(HOLD)\nRightExpand.set_stopping(HOLD)\n# Set Velocities Of Components\nCatapult1.set_velocity(40, PERCENT)\nCatapult2.set_velocity(40, PERCENT)\nLeftExpand.set_velocity(10, PERCENT)\nRightExpand.set_velocity(10, PERCENT)\n# Displays The Throttle On The Controller\ncontroller_1.screen.set_cursor(1, 1)\ncontroller_1.screen.print(\"Throttle: \")\n# Throttle Is The Speed Multiplier Times 10\ncontroller_1.screen.print(SpeedMult * 10)\n\n#################### Functions ####################\n\n########## Movement ##########\n\n# Custom Movement Controller Class\ndef Movement_Action(speed, rotate, waits, rev):\n    # Movement_Action(Speed[%], Rotate?, Wait?[0 = none, >0 = time inputted], Revolutions[overides stopping])\n    global SpeedMult, Preset, Timeout\n    if Timeout == False:\n        Timeout = True\n        if rev > 0:\n            # Sets Preset To True\n            Preset = True\n            # If A Predefined Amount Of Rotations Is Specified Perform This\n            if debug:\n                # Prints Turn Count\n                brain.screen.next_row()\n                brain.screen.print(rev)\n            # Sets Velocity Of Drive To Inputted Value\n            Motor_Velo(speed)\n            if debug:\n                brain.screen.next_row()\n                # Reached Velocity\n                brain.screen.print(\"V1\")\n            # Start The Drive Wheels\n            FrontRight.spin_for(FORWARD, rev, TURNS, wait=False)\n            FrontLeft.spin_for(FORWARD, rev, TURNS, wait=False)\n            BackRight.spin_for(FORWARD, rev, TURNS, wait=False)\n            # Last Wheel Will Prevent Progression Until Turn Is Completed\n            BackLeft.spin_for(FORWARD, rev, TURNS, wait=True)\n            # Sets Preset To False\n            Preset = False\n            if debug:\n                # Notification Of Completed Turn\n                brain.screen.next_row()\n                brain.screen.print(\"Turn Completed\")\n        elif rotate == False:\n            # Sets Velocity Of Drive To Inputted Value\n            if Preset == True:\n                Motor_Velo(speed)\n            else:\n                Motor_Driver()\n            #Motor_Velo(speed)\n            # Start The Drive Wheels\n            FrontRight.spin(FORWARD)\n            FrontLeft.spin(FORWARD)\n            BackRight.spin(FORWARD)\n            BackLeft.spin(FORWARD)\n        else:\n            # Sets Velocity Of Drive To Inputted Value\n            Motor_Velo(speed)\n            # Start The Drive Wheels\n            FrontRight.spin(FORWARD)\n            FrontLeft.spin(REVERSE)\n            BackRight.spin(FORWARD)\n            BackLeft.spin(REVERSE)\n        if waits > 0:\n            # If Wait Was Specified Wait The Amount Of Time Inputted In Seconds Then Stop Drive Motors\n            wait(waits, SECONDS)\n            Stop_motors()\n        Timeout = False\n    else:\n        pass\ndef Motor_Velo(speed):\n    # Sets All Drive Motor Velocities To Inputted Value\n    FrontRight.set_velocity(speed, PERCENT)\n    FrontLeft.set_velocity(speed, PERCENT)\n    BackRight.set_velocity(speed, PERCENT)\n    BackLeft.set_velocity(speed, PERCENT)\n\ndef Motor_Driver():\n    # Sets All Drive Motor Velocities To Inputted Value\n    if controller_1.axis2.position() - controller_1.axis3.position() < 30 and controller_1.axis2.position() - controller_1.axis3.position() > -30:\n        # If Joysticks Are Within 30 Percent Difference Syncronize Them And Drive Straight\n        FrontRight.set_velocity(controller_1.axis2.position() * SpeedMult, PERCENT)\n        FrontLeft.set_velocity(controller_1.axis2.position() * SpeedMult, PERCENT)\n        BackRight.set_velocity(controller_1.axis2.position() * SpeedMult, PERCENT)\n        BackLeft.set_velocity(controller_1.axis2.position() * SpeedMult, PERCENT)\n    else:\n        # If Drive Joysticks Are Not Synced Run Joystick Inputs Independently\n        FrontRight.set_velocity(controller_1.axis3.position() * SpeedMult, PERCENT)\n        FrontLeft.set_velocity(controller_1.axis2.position() * SpeedMult, PERCENT)\n        BackRight.set_velocity(controller_1.axis3.position() * SpeedMult, PERCENT)\n        BackLeft.set_velocity(controller_1.axis2.position() * SpeedMult, PERCENT)\n\ndef Stop_motors():\n    #Motor_Velo(0)\n    # Stops The Drive Motors\n    FrontRight.stop()\n    FrontLeft.stop()\n    BackRight.stop()\n    BackLeft.stop()\n\n########## Position Calculation ##########\n\n\ndef TurnTo(degrees):\n    # Overides Stopping\n    global Preset\n    Preset = True\n    # TurnTo(degrees[Angle About The Origin Of Robot])\n    # Sets Margin Of Success\n    askew = 3\n    # Gets The Difference Between The Degrees And The Current Degrees\n    d = GPS_Sense.heading() - degrees % 360\n  \n    if d >= 180 or (d <= 0 and d > -180):\n        # Start The Turn To The Right\n        Movement_Action(10, True, 0, 0)\n        # Waits Until Heading Is Facing Degree Margin\n        while (GPS_Sense.heading() < degrees - askew) or (GPS_Sense.heading() > degrees + askew):\n            pass\n        # Stop The Drive After The Robot Reaches The Point\n        Stop_motors()\n\n    elif d <= -180 or (d > 0 and d < 180):\n        # Start The Turn To The LEft\n        Movement_Action(-10, True, 0, 0)\n        # Waits Until Heading Is Facing Degree Margin\n        while (GPS_Sense.heading() > degrees + askew) or (GPS_Sense.heading() < degrees - askew): \n            pass\n        # Stop The Drive After The Robot Reaches The Point\n        Stop_motors()\n    else:\n        # If Result Out Of Bounds\n        if debug:\n            brain.screen.print(\"Error\")\n    # Returns Control Of Stopping\n    Preset = False\n\ndef GoTo(x,y,speed):\n    global Preset\n    # Overides Stopping\n    Preset = True\n    # Get The Slope Of The Line Between The Current Position And The Position To Go To\n    deltax = x - GPS_Sense.x_position(MM)\n    deltay = y - GPS_Sense.y_position(MM)\n    # Find The Angle Between The Current Position And The Position To Go To On a Right Triangle\n    # Then Convert The Radian Output To Degrees And Locate It On The Unit Circle\n    angle = math.atan2(deltax,deltay) * 180 / math.pi % 360\n    # Calculates The Distance To The Point\n    Dist = math.sqrt(deltax**2 + deltay**2)\n    # Turn To The Angle\n    TurnTo(angle)\n    Preset = True\n    wait(.2,SECONDS)\n    # Calculates The Number Of Turns The Wheels Need To Make To Reach A Certain Distance\n    turns = Dist / WheelC * ratio\n    # Start The Move\n    Movement_Action(speed, False, 0, turns)\n    # Stop The Drive After The Robot Reaches The Point\n    Stop_motors()\n    # Returns Control Of Stopping\n    Preset = False\n\n    \n########## Controllers ##########\n\n# Finds Out If A Joystick Is Being Pushed And Runs Its Dedicated Function\ndef ControllerHandler():\n    global Preset\n    while True:\n        # If Joystick Is Pushed Vertically\n        if math.fabs(controller_1.axis2.position()) > 10 or math.fabs(controller_1.axis3.position()) > 10:\n            Movement_Action(controller_1.axis2.position() * SpeedMult, False, 0, 0)\n        # If Joystick Is Pushed Horizontally\n        elif math.fabs(controller_1.axis2.position()) < 10 and math.fabs(controller_1.axis1.position()) > 10:\n            Movement_Action(controller_1.axis1.position() * SpeedMult, True, 0, 0)\n        # If Joystick Is Not Pushed\n        else:\n            # Check That We Have Stopping Control\n            if Preset == False:\n                # Stop Drive Motors\n                Stop_motors()\n        wait(5, MSEC)\n\n# Left Trigger Pressed\ndef L1():\n    global SpeedMult\n    # Throttle Decrease\n    if SpeedMult > 0:\n        SpeedMult = SpeedMult + -0.1\n        # Update Controller Screen With New Throttle\n        controller_1.screen.clear_row(1)\n        controller_1.screen.set_cursor(controller_1.screen.row(), 1)\n        controller_1.screen.set_cursor(1, 1)\n        controller_1.screen.print(\"Throttle: \")\n        controller_1.screen.print(SpeedMult * 10)\n\n# Right Trigger Pressed\ndef R1():\n    global SpeedMult\n    # Throttle Increase\n    if SpeedMult < 1:\n        SpeedMult = SpeedMult + 0.1\n        # Update Controller Screen With New Throttle\n        controller_1.screen.clear_row(1)\n        controller_1.screen.set_cursor(controller_1.screen.row(), 1)\n        controller_1.screen.set_cursor(1, 1)\n        controller_1.screen.print(\"Throttle: \")\n        controller_1.screen.print(SpeedMult * 10)\n\n# If Up Button Pressed Turn To 90 Degrees\ndef up():\n    TurnTo(90)\n\n# If Right Button Pressed Turn To 180 Degrees\ndef right():\n    TurnTo(180)\n\n# If Down Button Pressed Turn To 270 Degrees\ndef down():\n    TurnTo(270)\n\n# If Left Button Pressed Turn To 0 Degrees\ndef left():\n    TurnTo(0)\n\n# If A Button Pressed\ndef a():\n    while controller_1.buttonA.pressing():\n        pass\n    global Preset\n    Preset = True\n\n    RightExpand.set_velocity(100, PERCENT)\n    RightExpand.spin_to_position(90, DEGREES, False)\n    wait(.5, SECONDS)\n    # UnExpand\n    RightExpand.set_velocity(50, PERCENT)\n    RightExpand.spin_to_position(-10, DEGREES, False)\n    # Thread Stopping The Expansion\n    Thread(Close)\n\n    wait(.3, SECONDS)\n    RightExpand.set_velocity(10, PERCENT)\n\n    Movement_Action(-30, False, 1, 0)\n\n    # Catapult Triggers\n    Movement_Action(-10, False, 0, 0)\n    #Catapult_Toggle()\n    wait(2,SECONDS)############################################################################ CHANGE THIS 37:2 ###########################################################################\n    #Catapult_Toggle()\n\n    # Actions To Prepare To Move To Other Side Of Field\n    # Leave Match Load Bar\n    TurnTo(180)\n    Preset = True\n    wait(.2,SECONDS)\n    Movement_Action(100, 0, .5, 0)\n    wait(.2,SECONDS)\n    Movement_Action(-70, 0, .5, 0)\n    wait(.2,SECONDS)\n\n    # Nav To Center Line\n    GoTo(-500, 600, 70)\n    wait(.2,SECONDS)\n    Preset = False\n    # Face Other Side Of Field\n\n########## Robot Elements ##########\n\n# Operates The Catapult\ndef Catapult_Toggle():\n    global MatchLoad\n    # Operates The Catapult\n    if MatchLoad == False:\n        # Set Matchloading To True\n        MatchLoad = True\n        # Starts The Catapult\n        Catapult1.spin(REVERSE)\n        Catapult2.spin(REVERSE)\n\n    else:\n        # Set Matchloading To False\n        MatchLoad = False\n        # Stops The Catapult\n        Catapult1.stop()\n        Catapult2.stop()\n\ndef Catapult():\n    global MatchLoad, Preset\n    while True:\n        # Wait Until The Button Is Pressed\n        if controller_1.buttonB.pressing():\n            # Wait Until Button Is Released\n            while controller_1.buttonB.pressing():\n                pass\n            # Sets MatchLoading To True\n            MatchLoad = True\n            Preset = True\n            Movement_Action(-10, False, 0, 0)\n            # Start The Catapult\n            Catapult1.spin(REVERSE)\n            Catapult2.spin(REVERSE)\n            # Provide A Haptic Feedback For The Driver\n            controller_1.rumble(\"-\")\n            # Wait Until The Button Is Pressed Again\n            while not controller_1.buttonB.pressing():\n                pass\n            # Wait Until Button Is Released\n            while controller_1.buttonB.pressing():\n                pass\n            # Sets MatchLoading To False\n            MatchLoad = False\n            # Stops The Catapult\n            Catapult1.stop()\n            Catapult2.stop()\n            Preset = False\n        wait(5, MSEC)\n\n# Operates The Expansion\ndef ExpandLeft():\n    while True:\n        # Wait Until The Button Is Pressed\n        if controller_1.buttonL2.pressing():\n            # Wait Until Button Is Released\n            while controller_1.buttonL2.pressing():\n                pass\n            # Starts The Expansion Motor\n            LeftExpand.spin(FORWARD)\n            # Provide A Haptic Feedback For The Driver\n            controller_1.rumble(\"..\")\n            # Wait Until The Button Is Pressed Again\n            while not controller_1.buttonL2.pressing():\n                pass\n            # Wait Until Button Is Released\n            while controller_1.buttonL2.pressing():\n                pass\n            # Starts The Expansion Motor\n            LeftExpand.spin(REVERSE)\n            # Provide A Haptic Feedback For The Driver\n            controller_1.rumble(\"..\")\n            # Wait Until The Expansion Is Fully Retracted\n            wait(2, SECONDS)\n            # Stops The Expansion Motor\n            LeftExpand.stop()\n        wait(5, MSEC)\n\ndef ExpandRight():\n    while True:\n        # Wait Until The Button Is Pressed\n        if controller_1.buttonR2.pressing():\n            # Wait Until Button Is Released\n            while controller_1.buttonR2.pressing():\n                pass\n            # Starts The Expansion Motor\n            RightExpand.spin(FORWARD)\n            # Provide A Haptic Feedback For The Driver\n            controller_1.rumble(\"..\")\n            # Wait Until The Button Is Pressed Again\n            while not controller_1.buttonR2.pressing():\n                pass\n            # Wait Until Button Is Released\n            while controller_1.buttonR2.pressing():\n                pass\n            # Starts The Expansion Motor\n            RightExpand.spin(REVERSE)\n            # Provide A Haptic Feedback For The Driver\n            controller_1.rumble(\"..\")\n            # Wait Until The Expansion Is Fully Retracted\n            wait(2, SECONDS)\n            # Stops The Expansion Motor\n            RightExpand.stop()\n        wait(5, MSEC)\n\ndef Close():\n    # Stops The Expansion Motors After 2 Seconds\n    wait(2, SECONDS)\n    LeftExpand.stop()\n    RightExpand.stop()\n\n########## Actions ##########\n\n########## System Event Handlers ##########\n\n# Left Trigger Pressed\ncontroller_1.buttonL1.pressed(L1)\n\n# Right Trigger Pressed\ncontroller_1.buttonR1.pressed(R1)\n\n# Up Arrow Pressed\ncontroller_1.buttonUp.pressed(up)\n\n# Down Arrow Pressed\ncontroller_1.buttonDown.pressed(down)\n\n# Left Arrow Pressed\ncontroller_1.buttonLeft.pressed(left)\n\n# Right Arrow Pressed\ncontroller_1.buttonRight.pressed(right)\n\n# A Button Pressed\ncontroller_1.buttonA.pressed(a)\n\n# Add 15ms Delay To Make Sure Events Are Registered Correctly\nwait(15, MSEC)\n\n# Debug Function\ndef DEBUG():\n    global debug\n    # Set Debug To True To Run Debug Code Throughout File\n    debug = True\n    while True:\n        # Displays The Movement Controllers Inputs To Allow Debugging Of Controller\n        controller_1.screen.clear_row(2)\n        controller_1.screen.set_cursor(2,0)\n        # Gets Difference Between Joysticks\n        controller_1.screen.print(math.fabs(controller_1.axis2.position()) - math.fabs(controller_1.axis3.position()))\n        wait(100,MSEC)\n\n# Threads Certain Functions To Allow Them To Work At The Same Time\nws1 = Thread(Catapult)\nws2 = Thread(ControllerHandler)\nws3 = Thread(ExpandRight)\nws4 = Thread(ExpandLeft)\n#ws5 = Thread(DEBUG)","textLanguage":"python","rconfig":[{"port":[9],"name":"FrontLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"FrontRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"BackLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[2],"name":"BackRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[8],"name":"Catapult1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[3],"name":"Catapult2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[11],"name":"LeftExpand","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[20],"name":"RightExpand","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"GPS_Sense","customName":true,"deviceType":"GPS","deviceClass":"gps","setting":{"xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240219.10.00.00","appVersion":"3.1.0","minVersion":"3.1.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}